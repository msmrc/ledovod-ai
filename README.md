# Проект "Ледокол": Оптимизация расписания проводки судов во льдах

## Содержание
1. [Описание проекта](#description)
2. [Описание данных](#data)
3. [Описание этапов работы](#stages)
4. [Результаты работы](#results)
5. [Используемые библиотеки](#libs)

## Задача и сложности проекта

Идеальное решение для проходимости судов бы выглядело вот так:

<img src="https://i.imgur.com/VbDXIOc.png" width="800">

Где каждое судно проходит оптимальный путь без ожиданий.

Сложность заключается в том что для того чтобы подобрать оптимальное расписание для всех судов, нужно учитывать множество комбинаций и вариантов проходимости судов в зависимости от ледовой обстановки.

Количество комбинаций всех решений для 42 заявок составляет число с 19 нулями так что нам пришлось испльзовать другие методы для нахождения решения задачи.






## Алгоритм составления графа проходимости на основе данных о льдах

Для 

0. Образуем данные проходимости льда и разбиваем их по сетке координат.
1. Находим две точки на графе и берем их координаты. 
2. Строим путь между этими точками по болшому кругу <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Illustration_of_great-circle_distance.svg/220px-Illustration_of_great-circle_distance.svg.png" width="400">
3. Разбиваем путь на n точек
4. Для каждой точки на пути находим ближайшую точку данных по ледовой обстановке с помощью алгоритма K-d деревьев.
   1. Картинка
5. Строим граф, добавляя на рёбра метаданные о проходимости на участках пути.
6. Сохраняем.

Граф с данными о проходимости льда:

<img src="https://i.imgur.com/JDEUuD6.png" width="800">

## Алгоритм поиска оптимального пути на графе

Для нахождения оптимального пути на графе мы использовали алгоритм Djikstra из библиотеки NetworkX, который находит кратчайший путь между двумя вершинами на графе учитывая время прохождения для выбранного судна и ледокола.

<img src="https://qph.cf2.quoracdn.net/main-qimg-cfa6e0006734b0bd93431c754a8c42c4" width="400">

Алгоритм работает на принципе поиска кратчайшего пути на графе с помощью обновления весов рёбер в зависимости от времени прохождения. После нахождения кратчайшего пути мы можем узнать время прохождения и оптимальный путь для судна.

### Создание изначального расписания

#### Алгоритм First Come First Serve - Первый пришел - первый обслужен

Изначальное расписание строится так что мы **привязываем ледокол, который меньше всего ждать для нашего судна**. После этого мы привязываем к следующему судну ледокол, который меньше всего ждать для него и так далее.

В итоге мы получаем расписание где близко к минимуму сумма ожиданий всех ледоколов.

<img src="https://i.imgur.com/lBFv3xk.png" width="800">

При этом мы получаем решение при котором суммарный простой всех кораблей ожидающих ледокол составляет 190 дней или 4560 часов!

### Симуляция отжига для оптимизации расписания

<img src="https://upload.wikimedia.org/wikipedia/commons/1/10/Travelling_salesman_problem_solved_with_simulated_annealing.gif" width="400">



## Архитектура бакенда проекта

## Интеграция бакенда

## Описание API и примеры использования

## На что не хватило времени

### Создание навигационного решения основываясь на более подробных спутниковых снимков, данных о погоде и течениях

### Проводка судов без ледокола

### Создание картежей
